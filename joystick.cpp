/*
 * Copyright 2020-2022 AVSystem <avsystem@avsystem.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated by anjay_codegen.py on 2019-10-21 14:29:46
 *
 * LwM2M Object: Multiple Axis Joystick
 * ID: 3345, URN: urn:oma:lwm2m:ext:3345, Optional, Multiple
 *
 * This IPSO object can be used to report the position of a shuttle or
 * joystick control. A digital input is provided to report the state of
 * an associated push button.
 */

#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_list.h>
#include <avsystem/commons/avs_log.h>
#include <avsystem/commons/avs_memory.h>

#include <mbed.h>

#ifdef TARGET_DISCO_L496AG

#    define JOYSTICK_OBJ_LOG(...) avs_log(joystick_obj, __VA_ARGS__)

/**
 * Digital Input State: R, Single, Optional
 * type: boolean, range: N/A, unit: N/A
 * The current state of a digital input.
 */
#    define RID_DIGITAL_INPUT_STATE 5500

/**
 * Digital Input Counter: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * The number of times the input transitions from 0 to 1.
 */
#    define RID_DIGITAL_INPUT_COUNTER 5501

/**
 * X Value: R, Single, Optional
 * type: float, range: N/A, unit: N/A
 * The measured value along the X axis.
 */
#    define RID_X_VALUE 5702

/**
 * Y Value: R, Single, Optional
 * type: float, range: N/A, unit: N/A
 * The measured value along the Y axis.
 */
#    define RID_Y_VALUE 5703

#    define JOYSTICK_OID 3345

namespace {

class Joystick {
public:
    Joystick(PinName center,
             PinName left,
             PinName right,
             PinName up,
             PinName down)
            : center_(center),
              left_(left),
              right_(right),
              up_(up),
              down_(down),
              center_interrupt_(center),
              counter_() {
        center_.mode(PullDown);
        up_.mode(PullDown);
        left_.mode(PullDown);
        down_.mode(PullDown);
        right_.mode(PullDown);
        center_interrupt_.rise([this]() { ++counter_; });
    }

    int x_value() {
        if (left_) {
            return -1;
        } else if (right_) {
            return 1;
        }
        return 0;
    }

    int y_value() {
        if (down_) {
            return -1;
        } else if (up_) {
            return 1;
        }
        return 0;
    }

    bool pressed() {
        return center_;
    }

    int counter_value() {
        return counter_;
    }

    void counter_reset() {
        counter_ = 0;
    }

private:
    DigitalIn center_;
    DigitalIn left_;
    DigitalIn right_;
    DigitalIn up_;
    DigitalIn down_;
    InterruptIn center_interrupt_;
    int counter_;
};

} // namespace

typedef struct multiple_axis_joystick_struct {
    // Must be the first field in struct.
    const anjay_dm_object_def_t *def;
    Joystick joystick;
    int last_x_value;
    int last_y_value;
    int last_counter_value;
    bool last_pressed;
} multiple_axis_joystick_t;

static inline multiple_axis_joystick_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return (multiple_axis_joystick_t *) obj_ptr;
}

static int list_instances(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_dm_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;

    anjay_dm_emit(ctx, 0);
    return 0;
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;
    assert(iid == 0);
    (void) iid;

    multiple_axis_joystick_t *obj = get_obj(obj_ptr);
    obj->joystick.counter_reset();

    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_DIGITAL_INPUT_STATE, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_DIGITAL_INPUT_COUNTER, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_X_VALUE, ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_Y_VALUE, ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    multiple_axis_joystick_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);
    (void) iid;

    switch (rid) {
    case RID_DIGITAL_INPUT_STATE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_bool(ctx, obj->joystick.pressed());

    case RID_DIGITAL_INPUT_COUNTER:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, obj->joystick.counter_value());

    case RID_X_VALUE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_float(ctx, obj->joystick.x_value());

    case RID_Y_VALUE:
        return anjay_ret_float(ctx, obj->joystick.y_value());

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

namespace {

struct ObjDef : public anjay_dm_object_def_t {
    ObjDef() : anjay_dm_object_def_t() {
        oid = JOYSTICK_OID;

        handlers.list_instances = list_instances;
        handlers.instance_reset = instance_reset;

        handlers.list_resources = list_resources;
        handlers.resource_read = resource_read;

        handlers.transaction_begin = anjay_dm_transaction_NOOP;
        handlers.transaction_validate = anjay_dm_transaction_NOOP;
        handlers.transaction_commit = anjay_dm_transaction_NOOP;
        handlers.transaction_rollback = anjay_dm_transaction_NOOP;
    }
} const OBJ_DEF;

const anjay_dm_object_def_t **multiple_axis_joystick_object_create(void) {
    multiple_axis_joystick_t *obj = (multiple_axis_joystick_t *) avs_calloc(
            1, sizeof(multiple_axis_joystick_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    new (&obj->joystick) Joystick(USER_BUTTON, PI_9, PF_11, PI_8, PI_10);
    return &obj->def;
}

void multiple_axis_joystick_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        multiple_axis_joystick_t *obj = get_obj(def);
        obj->joystick.~Joystick();
        avs_free(obj);
    }
}

const anjay_dm_object_def_t **OBJ_DEF_PTR;

} // namespace

int joystick_object_install(anjay_t *anjay) {
    if (OBJ_DEF_PTR) {
        JOYSTICK_OBJ_LOG(ERROR, "Joystick Object has been already installed");
        return -1;
    }

    OBJ_DEF_PTR = multiple_axis_joystick_object_create();
    return anjay_register_object(anjay, OBJ_DEF_PTR);
}

void joystick_object_uninstall(anjay_t *anjay) {
    if (OBJ_DEF_PTR) {
        if (anjay_unregister_object(anjay, OBJ_DEF_PTR)) {
            JOYSTICK_OBJ_LOG(ERROR,
                             "Error during unregistering Joystick Object");
        }
        multiple_axis_joystick_object_release(OBJ_DEF_PTR);
        OBJ_DEF_PTR = nullptr;
    }
}

void joystick_object_update(anjay_t *anjay) {
    if (!OBJ_DEF_PTR) {
        return;
    }
    multiple_axis_joystick_t *obj = get_obj(OBJ_DEF_PTR);

    int curr_x_value = obj->joystick.x_value();
    int curr_y_value = obj->joystick.y_value();
    bool curr_pressed = obj->joystick.pressed();
    int curr_counter_value = obj->joystick.counter_value();

    if (curr_x_value != obj->last_x_value) {
        obj->last_x_value = curr_x_value;
        anjay_notify_changed(anjay, JOYSTICK_OID, 0, RID_X_VALUE);
    }

    if (curr_y_value != obj->last_y_value) {
        obj->last_y_value = curr_y_value;
        anjay_notify_changed(anjay, JOYSTICK_OID, 0, RID_Y_VALUE);
    }

    if (curr_pressed != obj->last_pressed) {
        obj->last_pressed = curr_pressed;
        anjay_notify_changed(anjay, JOYSTICK_OID, 0, RID_DIGITAL_INPUT_STATE);
    }

    if (curr_counter_value != obj->last_counter_value) {
        obj->last_counter_value = curr_counter_value;
        anjay_notify_changed(anjay, JOYSTICK_OID, 0, RID_DIGITAL_INPUT_COUNTER);
    }
}

#endif // TARGET_DISCO_L496AG
