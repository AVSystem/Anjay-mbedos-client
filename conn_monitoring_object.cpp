/*
 * Copyright 2020-2022 AVSystem <avsystem@avsystem.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated by anjay_codegen.py on 2019-07-16 17:53:16
 *
 * LwM2M Object: Connectivity Monitoring
 * ID: 4, URN: urn:oma:lwm2m:oma:4:1.1, Optional, Single
 *
 * This LwM2M Object enables monitoring of parameters related to network
 * connectivity. In this general connectivity Object, the Resources are
 * limited to the most general cases common to most network bearers. It
 * is recommended to read the description, which refers to relevant
 * standard development organizations (e.g. 3GPP, IEEE). The goal of the
 * Connectivity Monitoring Object is to carry information reflecting the
 * more up to date values of the current connection for monitoring
 * purposes. Resources such as Link Quality, Radio Signal Strength, Cell
 * ID are retrieved during connected mode at least for cellular networks.
 */
#include <assert.h>
#include <stdbool.h>

#include <CellularInterface.h>
#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_log.h>
#include <avsystem/commons/avs_memory.h>

#include "conn_monitoring_object.h"

#define CONN_MONITORING_OBJ_LOG(...) avs_log(conn_mon_obj, __VA_ARGS__)

/**
 * Network Bearer: R, Single, Mandatory
 * type: integer, range: 0-50, unit: N/A
 * Indicates the network bearer used for the current LwM2M communication
 * session from the network bearer list below.  The number range is split
 * into three categories: 0 - 20 are Cellular Bearers  21 - 40 are
 * Wireless Bearers  41 - 50 are Wireline Bearers  More specifically:  0:
 * GSM cellular network 1: TD-SCDMA cellular network 2: WCDMA cellular
 * network 3: CDMA2000 cellular network 4: WiMAX cellular network 5: LTE-
 * TDD cellular network 6: LTE-FDD cellular network 7: NB-IoT 8 - 20:
 * Reserved for other types of cellular network 21: WLAN network 22:
 * Bluetooth network 23: IEEE 802.15.4 network 24 - 40: Reserved for
 * other types of local wireless network 41: Ethernet 42: DSL 43: PLC 44
 * - 50: reserved for other types of wireline networks.
 */
#define RID_NETWORK_BEARER 0

/**
 * Available Network Bearer: R, Multiple, Mandatory
 * type: integer, range: 0-50, unit: N/A
 * Indicates a list of current available network bearer. Each Resource
 * Instance has a value from the network bearer list.
 */
#define RID_AVAILABLE_NETWORK_BEARER 1

/**
 * Radio Signal Strength: R, Single, Mandatory
 * type: integer, range: N/A, unit: dBm
 * Indicates the average value of the received signal strength indication
 * used in the current network bearer (as indicated by Resource 0 of this
 * Object). For the following network bearers the signal strength
 * parameters indicated below are represented by this resource: GSM:
 * RSSI UMTS:   RSCP LTE:    RSRP NB-IoT: NRSRP  For more details on
 * Network Measurement Report, refer to the appropriate Cellular or
 * Wireless Network standards, (e.g. for LTE Cellular Network refer to
 * 3GPP TS 36.133 specification).
 */
#define RID_RADIO_SIGNAL_STRENGTH 2

/**
 * Link Quality: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * This contains received link quality  e.g. LQI for IEEE 802.15.4 (range
 * 0...255), RxQual Downlink for GSM (range 0...7, refer to [3GPP 44.018]
 * for more details on Network Measurement Report encoding), RSRQ for
 * LTE, (refer to [3GPP 36.214]), NRSRQ for NB-IoT (refer to [3GPP
 * 36.214]).
 */
#define RID_LINK_QUALITY 3

/**
 * IP Addresses: R, Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * The IP addresses assigned to the connectivity interface. (e.g. IPv4,
 * IPv6, etc.)
 */
#define RID_IP_ADDRESSES 4

/**
 * Router IP Addresses: R, Multiple, Optional
 * type: string, range: N/A, unit: N/A
 * The IP address of the next-hop IP router, on each of the interfaces
 * specified in resource 4 (IP Addresses). Note: This IP Address doesnâ€™t
 * indicate the Server IP address.
 */
#define RID_ROUTER_IP_ADDRESSES 5

/**
 * Link Utilization: R, Single, Optional
 * type: integer, range: 0-100, unit: %
 * The percentage indicating the average utilization of the link to the
 * next-hop IP router.
 */
#define RID_LINK_UTILIZATION 6

/**
 * APN: R, Multiple, Optional
 * type: string, range: N/A, unit: N/A
 * Access Point Name in case Network Bearer Resource is a Cellular
 * Network.
 */
#define RID_APN 7

/**
 * Cell ID: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Serving Cell ID in case Network Bearer Resource is a Cellular Network.
 * As specified in TS [3GPP 23.003] and in [3GPP. 24.008]. Range
 * (0...65535) in GSM/EDGE UTRAN Cell ID has a length of 28 bits. Cell
 * Identity in WCDMA/TD-SCDMA. Range: (0...268435455). LTE Cell ID has a
 * length of 28 bits. Parameter definitions in [3GPP 25.331].
 */
#define RID_CELL_ID 8

/**
 * SMNC: R, Single, Optional
 * type: integer, range: 0-999, unit: %
 * Serving Mobile Network Code. This is applicable when the Network
 * Bearer Resource value is referring to a cellular network. As specified
 * in TS [3GPP 23.003].
 */
#define RID_SMNC 9

/**
 * SMCC: R, Single, Optional
 * type: integer, range: 0-999, unit: N/A
 * Serving Mobile Country Code. This is applicable when the Network
 * Bearer Resource value is referring to a cellular network. As specified
 * in TS [3GPP 23.003].
 */
#define RID_SMCC 10

/**
 * SignalSNR: R, Single, Optional
 * type: integer, range: N/A, unit: dB
 * SINR: Signal to Interference plus Noise Ratio SINR is the ratio of the
 * strength of the received signal to the strength of the received
 * interference signal (noise and interference).
 */
#define RID_SIGNALSNR 11

typedef struct connectivity_monitoring_struct {
    const anjay_dm_object_def_t *def;
    mbed::CellularContext *cellular_context;
    mbed::CellularNetwork *cellular_network;
} connectivity_monitoring_t;

static inline connectivity_monitoring_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, connectivity_monitoring_t, def);
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_NETWORK_BEARER, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_AVAILABLE_NETWORK_BEARER, ANJAY_DM_RES_RM,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_RADIO_SIGNAL_STRENGTH, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_LINK_QUALITY, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_IP_ADDRESSES, ANJAY_DM_RES_RM,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_ROUTER_IP_ADDRESSES, ANJAY_DM_RES_RM,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_LINK_UTILIZATION, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_APN, ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_CELL_ID, ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SMNC, ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SMCC, ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SIGNALSNR, ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    return 0;
}

static const char *ensure_non_null(const char *string) {
    return string ? string : "NONE";
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;
    assert(iid == 0);

    connectivity_monitoring_t *obj = get_obj(obj_ptr);
    assert(obj);

    enum {
        NB_CELLULAR_GSM = 0,
        NB_CELLULAR_TD_SCDMA,
        NB_CELLULAR_WCDMA,
        NB_CELLULAR_CDMA2000,
        NB_CELLULAR_WIMAX,
        NB_CELLULAR_LTE_TDD,
        NB_CELLULAR_LTE_FDD,

        NB_WIRELESS_WLAN = 21,
        NB_WIRELESS_BLUETOOTH,
        NB_WIRELESS_802_15_4,

        NB_WIRED_ETHERNET = 41,
        NB_WIRED_DSL,
        NB_WIRED_PLC
    };

    switch (rid) {
    case RID_NETWORK_BEARER:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, NB_CELLULAR_WCDMA);

    case RID_AVAILABLE_NETWORK_BEARER:
        switch (riid) {
        case 0:
            return anjay_ret_i32(ctx, NB_CELLULAR_GSM);
        case 1:
            return anjay_ret_i32(ctx, NB_CELLULAR_WCDMA);
        case 2:
            return anjay_ret_i32(ctx, NB_CELLULAR_LTE_FDD);
        case 3:
            return anjay_ret_i32(ctx, NB_WIRELESS_WLAN);
        case 4:
            return anjay_ret_i32(ctx, NB_WIRELESS_BLUETOOTH);
        default:
            AVS_UNREACHABLE(
                    "unexpected RIID for CM_RES_AVAILABLE_NETWORK_BEARER");
            return ANJAY_ERR_NOT_FOUND;
        }

    case RID_RADIO_SIGNAL_STRENGTH: {
        assert(riid == ANJAY_ID_INVALID);
        /**
         * get_signal_quality() returns value in dBm unit so it can be returned
         * directly as Radio Signal Strength resource.
         */
        int rssi;
        if (obj->cellular_network->get_signal_quality(rssi)) {
            rssi = mbed::CellularNetwork::SignalQualityUnknown;
        }
        return anjay_ret_i32(ctx, rssi);
    }

    case RID_LINK_QUALITY:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 255);

    case RID_IP_ADDRESSES:
        assert(riid == 0);
        return anjay_ret_string(
                ctx, ensure_non_null(obj->cellular_context->get_ip_address()));

    case RID_ROUTER_IP_ADDRESSES:
        assert(riid == 0);
        return anjay_ret_string(
                ctx, ensure_non_null(obj->cellular_context->get_gateway()));

    case RID_LINK_UTILIZATION:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 50);

    case RID_APN:
        assert(riid == 0);
        return anjay_ret_string(ctx, MBED_CONF_NSAPI_DEFAULT_CELLULAR_APN);

    case RID_CELL_ID:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 12345);

    case RID_SMNC:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0);

    case RID_SMCC:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0);

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int list_resource_instances(anjay_t *anjay,
                                   const anjay_dm_object_def_t *const *obj_ptr,
                                   anjay_iid_t iid,
                                   anjay_rid_t rid,
                                   anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    connectivity_monitoring_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_AVAILABLE_NETWORK_BEARER:
        anjay_dm_emit(ctx, 0);
        anjay_dm_emit(ctx, 1);
        anjay_dm_emit(ctx, 2);
        anjay_dm_emit(ctx, 3);
        anjay_dm_emit(ctx, 4);
        return 0;

    case RID_IP_ADDRESSES:
    case RID_ROUTER_IP_ADDRESSES:
    case RID_APN:
        anjay_dm_emit(ctx, 0);
        return 0;

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

namespace {

struct ObjDef : public anjay_dm_object_def_t {
    ObjDef() : anjay_dm_object_def_t() {
        oid = CONN_MONITORING_OID;

        handlers.list_instances = anjay_dm_list_instances_SINGLE;

        handlers.list_resources = list_resources;
        handlers.resource_read = resource_read;
        handlers.list_resource_instances = list_resource_instances;

        handlers.transaction_begin = anjay_dm_transaction_NOOP;
        handlers.transaction_validate = anjay_dm_transaction_NOOP;
        handlers.transaction_commit = anjay_dm_transaction_NOOP;
        handlers.transaction_rollback = anjay_dm_transaction_NOOP;
    }
} const OBJ_DEF;

const anjay_dm_object_def_t **
connectivity_monitoring_object_create(mbed::CellularContext *cell_ctx,
                                      mbed::CellularNetwork *net) {
    connectivity_monitoring_t *obj = (connectivity_monitoring_t *) avs_calloc(
            1, sizeof(connectivity_monitoring_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;
    obj->cellular_context = cell_ctx;
    obj->cellular_network = net;
    return &obj->def;
}

void connectivity_monitoring_object_release(
        const anjay_dm_object_def_t ***def) {
    if (*def) {
        connectivity_monitoring_t *obj = get_obj(*def);
        avs_free(obj);
        *def = NULL;
    }
}

const anjay_dm_object_def_t **OBJ_DEF_PTR;

} // namespace

int conn_monitoring_object_install(anjay_t *anjay,
                                   mbed::CellularContext *cell_ctx,
                                   mbed::CellularNetwork *net) {
    if (OBJ_DEF_PTR) {
        CONN_MONITORING_OBJ_LOG(
                ERROR,
                "Connectivity Monitoring Object has been already installed");
        return -1;
    }

    OBJ_DEF_PTR = connectivity_monitoring_object_create(cell_ctx, net);
    return anjay_register_object(anjay, OBJ_DEF_PTR);
}

void conn_monitoring_object_uninstall(anjay_t *anjay) {
    if (OBJ_DEF_PTR) {
        if (anjay_unregister_object(anjay, OBJ_DEF_PTR)) {
            CONN_MONITORING_OBJ_LOG(ERROR, "Error during unregistering "
                                           "Connectivity Monitoring Object");
        }
        connectivity_monitoring_object_release(&OBJ_DEF_PTR);
    }
}
